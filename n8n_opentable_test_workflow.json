
{
  "name": "OpenTable Scraper - Improved Extraction",
  "nodes": [
    {
      "parameters": {},
      "id": "27018783-a079-4469-bc2a-1c7c9135e808",
      "name": "Start",
      "type": "n8n-nodes-base.start",
      "typeVersion": 1,
      "position": [
        240,
        300
      ]
    },
    {
      "parameters": {
        "url": "https://app.scrapingbee.com/api/v1/?api_key=PE0EL019IKOKWT8MID15O5HQYGEPDC9FT6EQZK8DKJ7RBLP15MGGTOB8YQQMAKFGAD8Q1VA9RRTNIPK5&url=https%3A%2F%2Fwww.opentable.com%2Fs%2F%3Fk%3Dnew%2520york&forward_headers=true&render_js=true&wait=3000",
        "options": {
          "response": {
            "response": {
              "fullResponse": false,
              "responseFormat": "string"
            }
          },
          "headers": {
            "header": [
              {
                "name": "User-Agent",
                "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
              }
            ]
          }
        }
      },
      "id": "8482a524-76e3-4d43-9828-569a988185c0",
      "name": "Fetch via ScrapingBee",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        460,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Improved restaurant extraction with multiple strategies and better error handling\nlet html = '';\ntry {\n  const inputData = items[0] && items[0].json ? items[0].json : {};\n  html = inputData.data || inputData.body || inputData || '';\n  \n  if (typeof html !== 'string') {\n    html = String(html);\n  }\n  \n  console.log('HTML data received, length:', html.length, 'characters');\n  \n} catch (error) {\n  console.log('Error getting HTML data:', error.message);\n  return [{ json: { error: 'Failed to get HTML data', details: error.message } }];\n}\n\nif (!html || html.length === 0) {\n  console.log('No HTML data found');\n  return [{ json: { error: 'No HTML data received', html_length: 0 } }];\n}\n\n// Check for access restrictions or blocks\nif (html.includes('Access Denied') || html.includes('Blocked') || html.includes('Rate Limited') || html.includes('403 Forbidden')) {\n  console.log('Access restricted detected');\n  return [{ json: { error: 'Access restricted by website', html_sample: html.substring(0, 200) } }];\n}\n\nlet restaurants = [];\nlet debugInfo = {\n  strategies_attempted: [],\n  html_contains_script: html.includes('<script'),\n  html_contains_json: html.includes('application/json'),\n  html_sample: html.substring(0, 500)\n};\n\n// Strategy 1: Try to extract from primary-window-vars script tag\ntry {\n  debugInfo.strategies_attempted.push('primary-window-vars');\n  console.log('Attempting Strategy 1: primary-window-vars script tag');\n  \n  const scriptMatch = html.match(/<script id=\"primary-window-vars\" type=\"application\\/json\">(.*?)<\\/script>/s);\n  \n  if (scriptMatch) {\n    console.log('Found primary-window-vars script tag');\n    const jsonContent = scriptMatch[1];\n    \n    if (jsonContent && jsonContent.length > 0) {\n      const data = JSON.parse(jsonContent);\n      console.log('Successfully parsed JSON from primary-window-vars');\n      \n      // Multiple paths to try for restaurant data\n      const possiblePaths = [\n        data?.windowVariables?.__INITIAL_STATE__?.multiSearch?.restaurants,\n        data?.windowVariables?.__APOLLO_STATE__?.restaurants,\n        data?.windowVariables?.__INITIAL_STATE__?.restaurants,\n        data?.multiSearch?.restaurants\n      ];\n      \n      for (const restaurantData of possiblePaths) {\n        if (restaurantData && Array.isArray(restaurantData) && restaurantData.length > 0) {\n          console.log(`Found ${restaurantData.length} restaurants in data structure`);\n          \n          // Process first 5 restaurants for testing\n          const limitedRestaurants = restaurantData.slice(0, 5);\n          \n          for (const restaurant of limitedRestaurants) {\n            try {\n              const restaurantObj = {\n                restaurantId: restaurant.restaurantId || null,\n                name: restaurant.name || 'Unknown',\n                link: restaurant.urls?.profileLink?.link ? \n                  (restaurant.urls.profileLink.link.startsWith('http') ? \n                    restaurant.urls.profileLink.link : \n                    'https://www.opentable.com' + restaurant.urls.profileLink.link) : '',\n                cuisine: restaurant.primaryCuisine?.name || 'Unknown',\n                rating: restaurant.statistics?.reviews?.ratings?.overall?.rating || 0,\n                reviewCount: restaurant.statistics?.reviews?.allTimeTextReviewCount || 0,\n                priceBand: restaurant.priceBand?.name || 'Unknown',\n                neighborhood: restaurant.neighborhood?.name || 'Unknown',\n                address: restaurant.address ? \n                  [restaurant.address.line1, restaurant.address.city, restaurant.address.state]\n                    .filter(Boolean).join(', ') : 'Unknown',\n                phone: restaurant.contactInformation?.formattedPhoneNumber || '',\n                imageUrl: restaurant.photos?.profileV3?.medium?.url ? \n                  (restaurant.photos.profileV3.medium.url.startsWith('http') ? \n                    restaurant.photos.profileV3.medium.url : \n                    'https:' + restaurant.photos.profileV3.medium.url) : '',\n                description: (restaurant.description || '').substring(0, 500),\n                coordinates: {\n                  latitude: restaurant.coordinates?.latitude || null,\n                  longitude: restaurant.coordinates?.longitude || null\n                },\n                features: {\n                  bar: restaurant.features?.bar || false,\n                  outdoor: restaurant.features?.outdoor || false,\n                  counter: restaurant.features?.counter || false,\n                  highTop: restaurant.features?.highTop || false\n                },\n                hasTakeout: restaurant.hasTakeout || false,\n                isPromoted: restaurant.isPromoted || false,\n                topReview: restaurant.topReview?.highlightedText || '',\n                scraped_at: new Date().toISOString(),\n                source: 'OpenTable',\n                search_query: 'new york',\n                extraction_method: 'JSON parsing - primary-window-vars'\n              };\n              \n              restaurants.push(restaurantObj);\n              \n            } catch (error) {\n              console.log('Error processing individual restaurant:', error.message);\n            }\n          }\n          \n          if (restaurants.length > 0) {\n            break; // Successfully found restaurants, no need to try other paths\n          }\n        }\n      }\n    }\n  }\n} catch (error) {\n  console.log('Strategy 1 failed:', error.message);\n}\n\n// Strategy 2: Try to extract from any script tag containing restaurant data\nif (restaurants.length === 0) {\n  try {\n    debugInfo.strategies_attempted.push('any-script-with-restaurants');\n    console.log('Attempting Strategy 2: any script tag with restaurant data');\n    \n    const allScriptMatches = html.match(/<script[^>]*>(.*?)<\\/script>/gs) || [];\n    console.log(`Found ${allScriptMatches.length} script tags to analyze`);\n    \n    for (const scriptTag of allScriptMatches) {\n      if (scriptTag.includes('restaurant') && scriptTag.includes('name')) {\n        try {\n          // Extract JSON-like content\n          const jsonMatch = scriptTag.match(/\\{.*\\}/s);\n          if (jsonMatch) {\n            const jsonStr = jsonMatch[0];\n            const data = JSON.parse(jsonStr);\n            \n            // Recursively search for restaurant arrays\n            function findRestaurants(obj, path = '') {\n              if (Array.isArray(obj) && obj.length > 0 && obj[0].name) {\n                console.log(`Found restaurant array at path: ${path}`);\n                return obj;\n              }\n              \n              if (typeof obj === 'object' && obj !== null) {\n                for (const [key, value] of Object.entries(obj)) {\n                  const result = findRestaurants(value, path ? `${path}.${key}` : key);\n                  if (result) return result;\n                }\n              }\n              \n              return null;\n            }\n            \n            const foundRestaurants = findRestaurants(data);\n            if (foundRestaurants) {\n              restaurants = foundRestaurants.slice(0, 5).map(r => ({\n                json: {\n                  restaurantId: r.restaurantId || null,\n                  name: r.name || 'Unknown',\n                  extraction_method: 'JSON parsing - script tag search',\n                  raw_data: r\n                }\n              }));\n              break;\n            }\n          }\n        } catch (e) {\n          // Continue to next script tag\n        }\n      }\n    }\n  } catch (error) {\n    console.log('Strategy 2 failed:', error.message);\n  }\n}\n\n// Strategy 3: HTML parsing with CSS selectors (fallback)\nif (restaurants.length === 0) {\n  try {\n    debugInfo.strategies_attempted.push('html-css-selectors');\n    console.log('Attempting Strategy 3: HTML parsing with CSS selectors');\n    \n    // This would require a proper HTML parser, but we can try basic regex\n    const restaurantNameMatches = html.match(/data-test=\"restaurant-card\"[^>]*>.*?<h[^>]*>([^<]+)</gs) || [];\n    \n    if (restaurantNameMatches.length > 0) {\n      console.log(`Found ${restaurantNameMatches.length} potential restaurant names via HTML parsing`);\n      \n      restaurants = restaurantNameMatches.slice(0, 5).map((match, index) => {\n        const nameMatch = match.match(/<h[^>]*>([^<]+)/);\n        return {\n          json: {\n            restaurantId: `html-${index}`,\n            name: nameMatch ? nameMatch[1].trim() : `Restaurant ${index + 1}`,\n            extraction_method: 'HTML parsing - CSS selectors',\n            scraped_at: new Date().toISOString()\n          }\n        };\n      });\n    }\n  } catch (error) {\n    console.log('Strategy 3 failed:', error.message);\n  }\n}\n\n// Final results\nif (restaurants.length > 0) {\n  console.log(`Successfully extracted ${restaurants.length} restaurants`);\n  console.log('Sample restaurant:', JSON.stringify(restaurants[0], null, 2));\n  return restaurants.map(r => r.json ? { json: r.json } : r);\n} else {\n  console.log('No restaurants found with any strategy');\n  return [{ \n    json: { \n      error: 'No restaurants extracted', \n      debug_info: debugInfo,\n      strategies_attempted: debugInfo.strategies_attempted,\n      html_length: html.length,\n      contains_restaurant_text: html.toLowerCase().includes('restaurant'),\n      contains_opentable_text: html.toLowerCase().includes('opentable')\n    } \n  }];\n}"
      },
      "id": "dac1db94-fa39-42e0-919b-e0e70ef3c528",
      "name": "Extract Restaurant Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        680,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Debug and validate extracted data\nconst results = items || [];\n\nconsole.log(`Received ${results.length} items from extraction`);\n\nif (results.length === 0) {\n  console.log('No items received from previous node');\n  return [{ json: { error: 'No data received from extraction node' } }];\n}\n\n// Check if we got error information\nconst firstItem = results[0];\nif (firstItem.json && firstItem.json.error) {\n  console.log('Extraction failed with error:', firstItem.json.error);\n  console.log('Debug info:', JSON.stringify(firstItem.json.debug_info || {}, null, 2));\n  return results; // Return error info for debugging\n}\n\n// Filter valid restaurants\nconst validRestaurants = results.filter(item => {\n  return item.json && \n         item.json.name && \n         item.json.name !== 'Unknown' && \n         item.json.name.length > 0 &&\n         !item.json.error;\n});\n\nconsole.log(`Found ${validRestaurants.length} valid restaurants out of ${results.length} total items`);\n\nif (validRestaurants.length === 0) {\n  console.log('No valid restaurants found. First item details:');\n  console.log(JSON.stringify(firstItem, null, 2));\n  return [{ \n    json: { \n      error: 'No valid restaurants after filtering',\n      total_items: results.length,\n      sample_item: firstItem.json || firstItem\n    } \n  }];\n}\n\n// Process valid restaurants\nconst processedRestaurants = validRestaurants.map((item, index) => {\n  const restaurant = item.json;\n  \n  return {\n    ...restaurant,\n    processed_at: new Date().toISOString(),\n    processing_order: index + 1,\n    data_quality: {\n      has_name: !!restaurant.name,\n      has_link: !!restaurant.link,\n      has_rating: !!restaurant.rating,\n      has_cuisine: !!restaurant.cuisine,\n      has_address: !!restaurant.address\n    }\n  };\n});\n\nconsole.log('Successfully processed restaurants:');\nprocessedRestaurants.forEach((r, i) => {\n  console.log(`${i + 1}. ${r.name} (${r.cuisine}) - ${r.extraction_method}`);\n});\n\nreturn processedRestaurants.map(restaurant => ({ json: restaurant }));"
      },
      "id": "process-data",
      "name": "Process and Clean Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        900,
        300
      ]
    }
  ],
  "connections": {
    "Start": {
      "main": [
        [
          {
            "node": "Fetch via ScrapingBee",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch via ScrapingBee": {
      "main": [
        [
          {
            "node": "Extract Restaurant Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Restaurant Data": {
      "main": [
        [
          {
            "node": "Process and Clean Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "instanceId": "0192b40c03f1f0a5599cfa5317602d78af1f928c4282591b3a88a8e071138389"
  }
}
